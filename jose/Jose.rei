/**
{1 JSON Web Key}
*/

module Jwk: {
  /**
  {1 Public keys}

  These keys are safe to show and should be used to verify signed content.
  */
  module Pub: {
    /**
    [t] describes a Public JSON Web Key
    */
    type t = {
      alg: option(string),
      kty: string,
      use: option(string),
      n: string,
      e: string,
      kid: string,
      x5t: option(string),
    };

    /**
    [of_pub pub] takes a public key generated by Nocrypto and returns a result t or a message of what went wrong.
    */
    let of_pub: Nocrypto.Rsa.pub_ => result(t, [ | `Msg(string)]);

    /**
    [to_pub t] takes a public JWK and returns a result [Nocrypto.Rsa.pub] or a message of what went wrong.
    */
    let to_pub: t => result(Nocrypto.Rsa.pub_, [ | `Msg(string)]);

    /**
    [of_pub_pem pem] takes a public PEM as a string and returns a result a result t or a message of what went wrong.
    */
    let of_pub_pem: string => result(t, [ | `Msg(string)]);

    /**
    [to_pub_pem t] takes a public JWK and returns a result public PEM string or a message of what went wrong.
    */
    let to_pub_pem: t => result(string, [ | `Msg(string)]);

    /**
    [to_json t] takes a [t] and returns a [Yojson.Safe.t]
    */
    let to_json: t => Yojson.Safe.t;
    /**
    [of_json json] takes a [Yojson.Safe.t] and returns a [t]
    */
    let of_json: Yojson.Safe.t => result(t, [ | `Msg(string)]);

    /**
    [of_string json_string] takes a JSON string representation and tries to return a [t]
    */
    let of_string: string => result(t, [ | `Msg(string)]);

    /**
    [to_string t] takes a t and returns a JSON string representation
    */
    let to_string: t => string;
  };

  /**
  {1 Private keys}

  These keys are not safe to show and should be used to sign content.
  */
  module Priv: {
    /**
    [t] describes a Private JSON Web Key
    */
    type t = {
      kty: string,
      n: string,
      e: string,
      d: string,
      p: string,
      q: string,
      dp: string,
      dq: string,
      qi: string,
      alg: option(string),
      kid: string,
    };

    /**
    [of_priv priv] takes a private key generated by Nocrypto and returns a result t or a message of what went wrong.
    */
    let of_priv: Nocrypto.Rsa.priv => result(t, [ | `Msg(string)]);

    /**
    [to_priv t] takes a private JWK and returns a result Nocrypto.Rsa.priv or a message of what went wrong.
    */
    let to_priv: t => result(Nocrypto.Rsa.priv, [ | `Msg(string)]);

    /**
    [of_priv_pem pem] takes a PEM as a string and returns a result a result t or a message of what went wrong.
    */
    let of_priv_pem: string => result(t, [ | `Msg(string)]);

    /**
    [to_priv_pem t] takes a private JWK and returns a result PEM string or a message of what went wrong.
    */
    let to_priv_pem: t => result(string, [ | `Msg(string)]);

    /**
    [to_json t] takes a [t] and returns a [Yojson.Safe.t]
    */
    let to_json: t => Yojson.Safe.t;
    /**
    [of_json json] takes a [Yojson.Safe.t] and returns a [t]
    */
    let of_json: Yojson.Safe.t => result(t, [ | `Msg(string)]);

    /**
    [of_string json_string] takes a JSON string representation and tries to return a [t]
    */
    let of_string: string => result(t, [ | `Msg(string)]);

    /**
    [to_string t] takes a t and returns a JSON string representation
    */
    let to_string: t => string;
  };
};

/**

{1 JSON Web Key Set}
*/

module Jwks: {
  /**
  [t] describes a Private JSON Web Key Set
  */
  type t = {keys: list(Jwk.Pub.t)};

  /**
    [to_json t] takes a [t] and returns a [Yojson.Safe.t]
    */
  let to_json: t => Yojson.Safe.t;
  /**
    [of_json json] takes a [Yojson.Safe.t] and returns a [t].

    Keys that can not be serialized safely will be removed from the list
    */
  let of_json: Yojson.Safe.t => t;

  /**
    [of_string json_string] takes a JSON string representation and returns a [t].

    Keys that can not be serialized safely will be removed from the list
    */
  let of_string: string => t;

  /**
    [to_string t] takes a t and returns a JSON string representation
    */
  let to_string: t => string;
};

module Header: {
  /**
   The [header] has the following properties:
   - [alg] Algorithm - RS256 and none is currently the only supported algs
   - [jku] JWK Set URL
   - [jwk] JSON Web Key
   - [kid] Key ID - We currently always expect this to be there, this can change in the future
   - [x5t] X.509 Certificate SHA-1 Thumbprint
   - [x5t#S256] X.509 Certificate SHA-256 Thumbprint
   - [typ] Type
   - [cty] Content Type

   Not implemented:
   - [x5u] X.509 URL
   - [x5c] X.509 Certficate Chain
   - [crit] Critical

  {{: RFC }  https://tools.ietf.org/html/rfc7515#section-4.1 }
  */
  type t = {
    alg: [ | `RS256 | `none | `Unknown],
    jku: option(string),
    jwk: option(Jwk.Pub.t),
    kid: option(string),
    x5t: option(string),
    x5t256: option(string),
    typ: option(string),
    cty: option(string),
  };

  let make_header: (~typ: string=?, Jwk.Pub.t) => t;

  let of_string: string => result(t, [ | `Msg(string)]);
  let to_string: t => result(string, [ | `Msg(string)]);

  let to_json: t => Yojson.Safe.t;
  let of_json: Yojson.Safe.t => result(t, [ | `Msg(string)]);
};

/**
  {1 JSON Web Signature}

  {{: RFC }  https://tools.ietf.org/html/rfc7515 }
*/
module Jws: {
  type signature = string;

  type t = {
    header: Header.t,
    payload: string,
    signature,
  };

  let validate: (~jwks: Jwks.t, t) => result(t, [ | `Msg(string)]);

  let sign:
    (~header: Header.t, ~payload: string, Nocrypto.Rsa.priv) =>
    result(t, [ | `Msg(string)]);
};

/**

{1 JSON Web Token}
*/

module Jwt: {
  type payload = Yojson.Safe.t;
  type claim = (string, Yojson.Safe.t);

  let empty_payload: payload;

  type t;

  let add_claim: (string, Yojson.Safe.t, payload) => payload;

  let to_string: t => result(string, [ | `Msg(string)]);
  let of_string: string => result(t, [ | `Msg(string)]);

  let to_jws: t => result(Jws.t, [ | `Msg(string)]);
  let of_jws: Jws.t => result(t, [ | `Msg(string)]);

  let validate: (~jwks: Jwks.t, t) => result(t, [ | `Msg(string)]);
  let sign:
    (~header: Header.t, ~payload: payload, Nocrypto.Rsa.priv) =>
    result(t, [ | `Msg(string)]);
};
